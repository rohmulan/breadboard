import { makeRunJavascriptComponent } from "./support.js";
import type { Inputs, Outputs } from "../js-components/substitute.js";

/**
 * This function was generated by @breadboard-ai/build-code from
 * src/js-components/substitute.ts
 */
export const substitute = makeRunJavascriptComponent<Inputs, Outputs>({
  code: `"use strict";
// src/util.ts
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function unique(params) {
  return Array.from(new Set(params));
}
function toId(param) {
  return \`p-\${param}\`;
}
function isEmptyContent(content) {
  if (!content) return true;
  if (typeof content === "string") return true;
  if (!content.parts?.length) return true;
  if (content.parts.length > 1) return false;
  const part = content.parts[0];
  if (!("text" in part)) return true;
  if (part.text.trim() === "") return true;
  return false;
}
function isLLMContent(nodeValue) {
  if (typeof nodeValue !== "object" || !nodeValue) return false;
  if (nodeValue === null || nodeValue === void 0) return false;
  if ("role" in nodeValue && nodeValue.role === "$metadata") {
    return true;
  }
  return "parts" in nodeValue && Array.isArray(nodeValue.parts);
}
function isLLMContentArray(nodeValue) {
  if (!Array.isArray(nodeValue)) return false;
  if (nodeValue.length === 0) return true;
  return isLLMContent(nodeValue.at(-1));
}
function toTitle(id) {
  const spaced = id?.replace(/[_-]/g, " ");
  return (spaced?.at(0)?.toUpperCase() ?? "") + (spaced?.slice(1)?.toLowerCase() ?? "");
}

// src/js-components/substitute.ts
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function run(inputParams) {
  const { in: context = [], persona, task, ...inputs } = inputParams;
  const personaParams = findParams(persona);
  const taskParams = findParams(task);
  const params = mergeParams(personaParams, taskParams);
  const values = collectValues(params, inputs);
  if (context.length === 0 && !task) {
    throw new Error(
      "Both conversation Context and Prompt are empty. Need at least one of them."
    );
  }
  return {
    in: context,
    persona: subContent(persona, values),
    task: subContent(task, values),
    outs: collectOuts(personaParams, taskParams)
  };
}
function collectOuts(...paramsList) {
  const functionNames = unique(
    paramsList.flat().map((param) => {
      const { name, op } = param;
      if (op !== "out") return null;
      return name;
    }).filter(Boolean)
  );
  return functionNames.map((name) => {
    const toolName = \`TOOL_\${name.toLocaleUpperCase()}\`;
    return {
      name: toolName,
      description: \`Call this function when asked to invoke the "\${toolName}" tool.\`
    };
  });
}
function findParams(content) {
  const parts = content?.parts;
  if (!parts) return [];
  const results = parts.flatMap((part) => {
    if (!("text" in part)) return [];
    const matches = part.text.matchAll(
      /{{\\s*(?<name>[\\w-]+)(?:\\s*\\|\\s*(?<op>[\\w-]*)(?::\\s*"(?<arg>[\\w-]+)")?)?\\s*}}/g
    );
    return unique(Array.from(matches)).map((match) => {
      const name = match.groups?.name || "";
      const op = match.groups?.op || "";
      const arg = match.groups?.arg || "";
      if (!name) return null;
      return { name, op, arg, locations: [{ part, parts }] };
    }).filter(Boolean);
  });
  return results;
}
function mergeParams(...paramList) {
  const result = paramList.reduce((acc, params) => {
    for (const param of params) {
      if (param.op && param.op !== "in") {
        continue;
      }
      const { name, locations } = param;
      const existing = acc[name];
      if (existing) {
        existing.push(...locations);
      } else {
        acc[name] = locations;
      }
    }
    return acc;
  }, {});
  return result;
}
function subContent(content, values) {
  if (Array.isArray(content)) {
    content = content.at(-1);
  }
  if (isEmptyContent(content)) return "";
  return {
    role: content.role || "user",
    parts: mergeTextParts(
      splitToTemplateParts(content).flatMap((part) => {
        if ("param" in part) {
          const { op = "in" } = part;
          if (op === "in") {
            const value = values[part.param];
            if (typeof value === "string") {
              return { text: value };
            } else if (isLLMContent(value)) {
              return value.parts;
            } else if (isLLMContentArray(value)) {
              const last = value.at(-1);
              return last ? last.parts : [];
            } else {
              return { text: JSON.stringify(value) };
            }
          } else {
            return { text: \`"TOOL_\${part.param.toLocaleUpperCase()}"\` };
          }
        } else {
          return part;
        }
      })
    )
  };
}
function mergeTextParts(parts) {
  const merged = [];
  for (const part of parts) {
    if ("text" in part) {
      const last = merged[merged.length - 1];
      if (last && "text" in last) {
        last.text += part.text;
      } else {
        merged.push(part);
      }
    } else {
      merged.push(part);
    }
  }
  return merged;
}
function splitToTemplateParts(content) {
  const parts = [];
  for (const part of content.parts) {
    if (!("text" in part)) {
      parts.push(part);
      continue;
    }
    const matches = part.text.matchAll(
      /{{\\s*(?<name>[\\w-]+)(?:\\s*\\|\\s*(?<op>[\\w-]*)(?::\\s*"(?<arg>[\\w-]+)")?)?\\s*}}/g
    );
    let start = 0;
    for (const match of matches) {
      const name = match.groups?.name || "";
      const op = match.groups?.op;
      const arg = match.groups?.arg;
      const end = match.index;
      if (end > start) {
        parts.push({ text: part.text.slice(start, end) });
      }
      parts.push({ param: name, op, arg });
      start = end + match[0].length;
    }
    if (start < part.text.length) {
      parts.push({ text: part.text.slice(start) });
    }
  }
  return parts;
}
function collectValues(params, inputs) {
  const values = {};
  for (const param in params) {
    const id = toId(param);
    const value = inputs[id];
    if (!value) {
      const title = toTitle(param);
      throw new Error(\`Missing required parameter: \${title}\`);
    }
    values[param] = value;
  }
  return values;
}
`,
  inputSchema: {
    type: "object",
    properties: {
      in: {
        type: "array",
        items: {
          anyOf: [
            {
              type: "object",
              properties: {
                parts: {
                  type: "array",
                  items: {
                    anyOf: [
                      {
                        type: "object",
                        properties: { text: { type: "string" } },
                        required: ["text"],
                      },
                      {
                        type: "object",
                        properties: {
                          functionCall: {
                            type: "object",
                            properties: {
                              name: { type: "string" },
                              args: { type: "object" },
                            },
                            required: ["args", "name"],
                          },
                        },
                        required: ["functionCall"],
                      },
                    ],
                  },
                },
                role: { enum: ["model", "tool", "user"], type: "string" },
              },
              required: ["parts"],
            },
            {
              allOf: [
                {
                  type: "object",
                  properties: { role: { type: "string", const: "$metadata" } },
                  required: ["role"],
                },
                {
                  type: "object",
                  properties: {
                    type: { type: "string", const: "looper" },
                    data: {
                      type: "object",
                      properties: {
                        max: {
                          description:
                            'Maximum iterations to make. This can be used to create simple\n"repeat N times" loops.',
                          type: "number",
                        },
                        todo: {
                          description:
                            'Plan items. Each item represents one trip down the "Loop" output, and\nat the end of the list, the "Context Out".',
                          type: "array",
                          items: {
                            type: "object",
                            properties: { task: { type: "string" } },
                            required: ["task"],
                          },
                        },
                        doneMarker: {
                          description:
                            "The marker that will be used by others to signal completion of the job.",
                          type: "string",
                        },
                        done: {
                          description: "Indicator that this job is done.",
                          type: "boolean",
                        },
                        appendLast: {
                          description:
                            "Whether to append only the last item in the loop to the context or all\nof them.",
                          type: "boolean",
                        },
                        returnLast: {
                          description:
                            "Whether to return only last item from the context as the final product\nor all of them;",
                          type: "boolean",
                        },
                        next: { description: "The next task.", type: "string" },
                      },
                    },
                  },
                  required: ["data", "type"],
                },
              ],
            },
            {
              allOf: [
                {
                  type: "object",
                  properties: { role: { type: "string", const: "$metadata" } },
                  required: ["role"],
                },
                {
                  type: "object",
                  properties: {
                    type: { type: "string", const: "split" },
                    data: {
                      type: "object",
                      properties: {
                        type: {
                          description:
                            "There are three types of split markers:\n- start: the beginning of the split\n- next: the separator between the split parts\n- end: the end of the split",
                          enum: ["end", "next", "start"],
                          type: "string",
                        },
                        id: {
                          description: "Unique identifier for the split.",
                          type: "string",
                        },
                      },
                      required: ["id", "type"],
                    },
                  },
                  required: ["data", "type"],
                },
              ],
            },
          ],
        },
      },
      persona: {
        type: "object",
        properties: {
          parts: {
            type: "array",
            items: {
              anyOf: [
                {
                  type: "object",
                  properties: { text: { type: "string" } },
                  required: ["text"],
                },
                {
                  type: "object",
                  properties: {
                    functionCall: {
                      type: "object",
                      properties: {
                        name: { type: "string" },
                        args: { type: "object" },
                      },
                      required: ["args", "name"],
                    },
                  },
                  required: ["functionCall"],
                },
              ],
            },
          },
          role: { enum: ["model", "tool", "user"], type: "string" },
        },
        required: ["parts"],
      },
      task: {
        type: "object",
        properties: {
          parts: {
            type: "array",
            items: {
              anyOf: [
                {
                  type: "object",
                  properties: { text: { type: "string" } },
                  required: ["text"],
                },
                {
                  type: "object",
                  properties: {
                    functionCall: {
                      type: "object",
                      properties: {
                        name: { type: "string" },
                        args: { type: "object" },
                      },
                      required: ["args", "name"],
                    },
                  },
                  required: ["functionCall"],
                },
              ],
            },
          },
          role: { enum: ["model", "tool", "user"], type: "string" },
        },
        required: ["parts"],
      },
    },
  },
  outputSchema: {
    type: "object",
    properties: {
      in: {
        type: "array",
        items: {
          anyOf: [
            {
              type: "object",
              properties: {
                parts: {
                  type: "array",
                  items: {
                    anyOf: [
                      {
                        type: "object",
                        properties: { text: { type: "string" } },
                        required: ["text"],
                      },
                      {
                        type: "object",
                        properties: {
                          functionCall: {
                            type: "object",
                            properties: {
                              name: { type: "string" },
                              args: { type: "object" },
                            },
                            required: ["args", "name"],
                          },
                        },
                        required: ["functionCall"],
                      },
                    ],
                  },
                },
                role: { enum: ["model", "tool", "user"], type: "string" },
              },
              required: ["parts"],
            },
            {
              allOf: [
                {
                  type: "object",
                  properties: { role: { type: "string", const: "$metadata" } },
                  required: ["role"],
                },
                {
                  type: "object",
                  properties: {
                    type: { type: "string", const: "looper" },
                    data: {
                      type: "object",
                      properties: {
                        max: {
                          description:
                            'Maximum iterations to make. This can be used to create simple\n"repeat N times" loops.',
                          type: "number",
                        },
                        todo: {
                          description:
                            'Plan items. Each item represents one trip down the "Loop" output, and\nat the end of the list, the "Context Out".',
                          type: "array",
                          items: {
                            type: "object",
                            properties: { task: { type: "string" } },
                            required: ["task"],
                          },
                        },
                        doneMarker: {
                          description:
                            "The marker that will be used by others to signal completion of the job.",
                          type: "string",
                        },
                        done: {
                          description: "Indicator that this job is done.",
                          type: "boolean",
                        },
                        appendLast: {
                          description:
                            "Whether to append only the last item in the loop to the context or all\nof them.",
                          type: "boolean",
                        },
                        returnLast: {
                          description:
                            "Whether to return only last item from the context as the final product\nor all of them;",
                          type: "boolean",
                        },
                        next: { description: "The next task.", type: "string" },
                      },
                    },
                  },
                  required: ["data", "type"],
                },
              ],
            },
            {
              allOf: [
                {
                  type: "object",
                  properties: { role: { type: "string", const: "$metadata" } },
                  required: ["role"],
                },
                {
                  type: "object",
                  properties: {
                    type: { type: "string", const: "split" },
                    data: {
                      type: "object",
                      properties: {
                        type: {
                          description:
                            "There are three types of split markers:\n- start: the beginning of the split\n- next: the separator between the split parts\n- end: the end of the split",
                          enum: ["end", "next", "start"],
                          type: "string",
                        },
                        id: {
                          description: "Unique identifier for the split.",
                          type: "string",
                        },
                      },
                      required: ["id", "type"],
                    },
                  },
                  required: ["data", "type"],
                },
              ],
            },
          ],
        },
      },
      persona: {
        anyOf: [
          {
            type: "object",
            properties: {
              parts: {
                type: "array",
                items: {
                  anyOf: [
                    {
                      type: "object",
                      properties: { text: { type: "string" } },
                      required: ["text"],
                    },
                    {
                      type: "object",
                      properties: {
                        functionCall: {
                          type: "object",
                          properties: {
                            name: { type: "string" },
                            args: { type: "object" },
                          },
                          required: ["args", "name"],
                        },
                      },
                      required: ["functionCall"],
                    },
                  ],
                },
              },
              role: { enum: ["model", "tool", "user"], type: "string" },
            },
            required: ["parts"],
          },
          { type: "string" },
        ],
      },
      task: {
        anyOf: [
          {
            type: "object",
            properties: {
              parts: {
                type: "array",
                items: {
                  anyOf: [
                    {
                      type: "object",
                      properties: { text: { type: "string" } },
                      required: ["text"],
                    },
                    {
                      type: "object",
                      properties: {
                        functionCall: {
                          type: "object",
                          properties: {
                            name: { type: "string" },
                            args: { type: "object" },
                          },
                          required: ["args", "name"],
                        },
                      },
                      required: ["functionCall"],
                    },
                  ],
                },
              },
              role: { enum: ["model", "tool", "user"], type: "string" },
            },
            required: ["parts"],
          },
          { type: "string" },
        ],
      },
      outs: { type: "array", items: { $ref: "#/definitions/def-11" } },
    },
    required: ["in", "outs", "persona", "task"],
    definitions: {
      "def-11": {
        type: "object",
        properties: {
          name: { type: "string" },
          description: { type: "string" },
          parameters: { $ref: "#/definitions/def-15" },
        },
        required: ["name"],
      },
      "def-15": {
        type: "object",
        properties: {
          title: { type: "string" },
          description: { type: "string" },
          type: {
            anyOf: [
              { type: "array", items: { type: "string" } },
              { type: "string" },
            ],
          },
          properties: { type: "object" },
          required: { type: "array", items: { type: "string" } },
          format: { type: "string" },
          behavior: {
            description:
              "Can be used to provide additional hints to the UI or to other parts of\nthe system about behavior of this particular input/output or input/output\nport.",
            type: "array",
            items: {
              enum: [
                "at-wireable",
                "board",
                "bubble",
                "config",
                "deprecated",
                "error",
                "google-drive-file-id",
                "google-drive-query",
                "hint-advanced",
                "hint-audio",
                "hint-chat-mode",
                "hint-code",
                "hint-controller",
                "hint-image",
                "hint-multimodal",
                "hint-preview",
                "hint-single-line",
                "hint-text",
                "json-schema",
                "llm-content",
                "main-port",
                "module",
                "ports-spec",
                "reactive",
                "side",
                "stream",
                "transient",
              ],
              type: "string",
            },
          },
          icon: {
            description:
              "If present, allows specifying an icon for the property. This icon will\nbe used when rendering the property in an editor.",
            type: "string",
          },
          transient: { type: "boolean" },
          enum: {
            type: "array",
            items: {
              anyOf: [
                {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    title: { type: "string" },
                    description: { type: "string" },
                    icon: { type: "string" },
                  },
                  required: ["id"],
                },
                { type: "string" },
              ],
            },
          },
          default: {
            description:
              "The default value of the schema. The UI can use this to pre-populate a\nfield with a value, if there is no `examples` present.",
            type: "string",
          },
          additionalProperties: {
            anyOf: [{ $ref: "#/definitions/def-15" }, { type: "boolean" }],
          },
          items: {
            anyOf: [
              { $ref: "#/definitions/def-15" },
              { type: "array", items: { $ref: "#/definitions/def-15" } },
            ],
          },
          minItems: { type: "number" },
          examples: {
            description:
              "Can be used by UI to pre-populate a field with a value that could be\nused as an example.",
            type: "array",
            items: { type: "string" },
          },
        },
      },
    },
  },
});
