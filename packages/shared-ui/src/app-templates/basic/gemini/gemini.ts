export type LLMContent = {
  role?: string;
  parts: DataPart[];
};

export type DataPart = FunctionCallCapabilityPart | TextCapabilityPart;

export type TextCapabilityPart = {
  text: string;
};

export type GeminiSchema = {
  type: "string" | "number" | "integer" | "boolean" | "object" | "array";
  format?: string;
  description?: string;
  nullable?: boolean;
  enum?: string[];
  maxItems?: string;
  minItems?: string;
  properties?: Record<string, GeminiSchema>;
  required?: string[];
  items?: GeminiSchema;
};

export type FunctionCallCapabilityPart = {
  functionCall: {
    name: string;
    args: object;
  };
};

export type FunctionDeclaration = {
  name: string;
  description: string;
  parameters?: GeminiSchema;
};

export type Tool = {
  function_declarations?: FunctionDeclaration[];
};

export type HarmBlockThreshold =
  // Content with NEGLIGIBLE will be allowed.
  | "BLOCK_LOW_AND_ABOVE"
  // Content with NEGLIGIBLE and LOW will be allowed.
  | "BLOCK_MEDIUM_AND_ABOVE"
  // Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed.
  | "BLOCK_ONLY_HIGH"
  // All content will be allowed.
  | "BLOCK_NONE"
  // Turn off the safety filter.
  | "OFF";

export type HarmCategory =
  // Gemini - Harassment content
  | "HARM_CATEGORY_HARASSMENT"
  //	Gemini - Hate speech and content.
  | "HARM_CATEGORY_HATE_SPEECH"
  // Gemini - Sexually explicit content.
  | "HARM_CATEGORY_SEXUALLY_EXPLICIT"
  // 	Gemini - Dangerous content.
  | "HARM_CATEGORY_DANGEROUS_CONTENT"
  // Gemini - Content that may be used to harm civic integrity.
  | "HARM_CATEGORY_CIVIC_INTEGRITY";

export type SafetySetting = {
  category: HarmCategory;
  threshold: HarmBlockThreshold;
};

export type GeminiBody = {
  contents: LLMContent[];
  tools?: Tool[];
  systemInstruction?: LLMContent;
  safetySettings?: SafetySetting[];
  generationConfig?: GenerationConfig;
};

export type GenerationConfig = {
  responseMimeType?: "text/plain" | "application/json" | "text/x.enum";
  responseSchema?: GeminiSchema;
};

export type FinishReason =
  // Natural stop point of the model or provided stop sequence.
  | "STOP"
  // The maximum number of tokens as specified in the request was reached.
  | "MAX_TOKENS"
  // The response candidate content was flagged for safety reasons.
  | "SAFETY"
  // The response candidate content was flagged for image safety reasons.
  | "IMAGE_SAFETY"
  // The response candidate content was flagged for recitation reasons.
  | "RECITATION"
  // The response candidate content was flagged for using an unsupported language.
  | "LANGUAGE"
  // Unknown reason.
  | "OTHER"
  // Token generation stopped because the content contains forbidden terms.
  | "BLOCKLIST"
  // Token generation stopped for potentially containing prohibited content.
  | "PROHIBITED_CONTENT"
  // Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
  | "SPII"
  // The function call generated by the model is invalid.
  | "MALFORMED_FUNCTION_CALL";

export type Candidate = {
  content?: LLMContent;
  finishReason?: FinishReason;
  safetyRatings?: SafetySetting[];
  tokenOutput: number;
  // groundingMetadata: GroundingMetadata;
};

export type GeminiErrorResponse = {
  code?: number;
  message?: string;
  status?: string;
  details?: object[];
};

export type GeminiAPIOutputs = {
  candidates: Candidate[];
};

function endpointURL(model?: string) {
  if (!model) {
    model = "gemini-2.0-flash";
  }
  return `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=AIzaSyDdyPzV1XXID29vpefaybtUwTeK5wSXnuY`;
}

export async function gemini(
  userInputContext: LLMContent[],
  boardDescription: string
): Promise<void> {
  console.log("Start fetching from gemini API");
  //Manually build userInputContext for testing purpose
  // userInputContext = [
  //   {
  //     role: "user",
  //     parts: [
  //       {
  //         text: "What is the time right now",
  //       },
  //     ],
  //   },
  //   {
  //     role: "model", 
  //     parts: [
  //       {
  //         text: "The current time is Thu May 08 2025.",
  //       },
  //     ],
  //   },
  //   {
  //       role: "user", 
  //       parts: [
  //         {
  //           text: "Do you know the exact time, including hours, minutes, and seconds?",
  //         },
  //       ],
  //     },
  // ];

  // User Oath token in header to call Gemini instead of api key
  //   headers: {
  //     Authorization: `Bearer ${accessToken}`,
  //   },

  const requestInit: RequestInit = {
    method: "POST",
    // headers: { Authorization: `Bearer ${accessToken}` },
    headers: {},
  };
  requestInit.body = JSON.stringify(
    consturctGeminiBody(userInputContext, boardDescription)
  );
  const url = endpointURL("gemini-2.0-flash");
  const data = await fetch(url, requestInit);
  if (!data.ok) {
    console.error("Error fetching from Gemini API. Status:", data.status);
    const errorResponse = await data.json(); // Assuming error response is JSON
    const err = errorResponse.error as GeminiErrorResponse;
    console.error("Error details:", errorResponse);
    console.dir(err);
    // Error details: {
    //     error: {
    //       code: 403,
    //       message: 'Request had insufficient authentication scopes.',
    //       status: 'PERMISSION_DENIED',
    //       details: [ [Object], [Object] ]
    //     }
    //   }
  } else {
    console.log("Complete fetching from gemini API, status:", data.status);
    // Maybe define a response data type GeminiOutput to parse the response?
    const res = (await data.json()) as GeminiAPIOutputs;
    console.dir(res);
    console.log("Print candidate to see result...");
    const candidate = res.candidates?.at(0);
    if (!candidate) {
      console.log("Unable to get a good response from Gemini");
      return;
    }
    if ("content" in candidate) {
      console.log("Printing content from the Gemini response");
      console.dir(candidate.content?.parts[0]);
    }
  }
}

function consturctGeminiBody(
  userInputContext: LLMContent[],
  boardDescription: string
): GeminiBody {
  const tools: Tool[] = [
    {
      function_declarations: [
        {
          name: "execute_flow",
          description: `Executes a specific flow to perform an action based on user input. ${boardDescription || ""}`,
          parameters: {
            type: "object",
            properties: {
              flow_user_input: {
                type: "string",
                description: "The flow input.",
              },
            },
            required: ["flow_user_input"],
          },
        },
      ],
    },
  ];
  const systemInstruction: LLMContent = {
    parts: [
      {
        text: buildSystemInstructionText(),
      },
    ],
  };

  const safetySettings: SafetySetting[] = [
    {
      category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      threshold: "BLOCK_NONE",
    },
    {
      category: "HARM_CATEGORY_HATE_SPEECH",
      threshold: "BLOCK_NONE",
    },
    {
      category: "HARM_CATEGORY_HARASSMENT",
      threshold: "BLOCK_NONE",
    },
    {
      category: "HARM_CATEGORY_DANGEROUS_CONTENT",
      threshold: "BLOCK_NONE",
    },
  ];
  const body: GeminiBody = {
    contents: userInputContext,
    tools: tools,
    systemInstruction: systemInstruction,
    safetySettings: safetySettings,
  };
  return body;
}

function buildSystemInstructionText(): string {
  const now = new Date();
  const timeString = now.toDateString();
  const userInfo = `**User information:**
* The current time where the user is located is ${timeString}.`;
  const commonSense = `**Use your knowledge, creativity and common sense:**
* Never ask for clarification for optional tool parameters. You can simply ignore them if they are not provided.
* For non-critical, but required parameters (like title, description, subject, etc.) you should use your creativity to come up with a good value based on the context, when the user did not provide one.
* You can translate across languages, you can do almost any text processing or manipulation.
* You can answer in any language, if the user asks for it.`;
  const commonPatterns = `**Common patterns:**
1. The user asks for something that is not possible to achieve with the current tools or via your knowledge (eg: "please restart my computer").
* Expected behavior: Let the user immediately know that you cannot perform this action, and offer to perform an alternative solution.
2. The user refers to a date (e.g. "next Tuesday", "Friday", "Christmas", "1st October"), but does not provide the full YYYY-MM-DD date.
* For past events it is always the last occurrence, for future events (eg: time off, create event, new deadline) it is always the next occurrence compared to the current time, that is 2025-02-25 12:37:30 +0100 CET (Week 08, Tuesday).
* Expected behavior: Do not ask back, but use your best guess.
3. Generating code snippets, coding and debugging. Since you are an expert in software development, you should answer the user directly when they ask you to provide code, or debug. Do not invoke any tools in this case.
* Examples: "write a python code that counts the vowels in 'banana'", "what is the problem with this code? code: ...", "explain this code to me: ...", "debug this code: ...", "fix this code: ...", "write a code that calculates <task>", "how to reverse a string in java?".
* Expected behavior: You answer the user directly with the generated code, or the explanation of the code. You make sure that you highlight the pros and cons of the various approaches.`;

  const systemInstruction = `${userInfo}\n${commonSense}\n${commonPatterns}`;
  return systemInstruction;
}
